{"version":3,"file":"json-audio-player.js","sources":["../src/json-audio-player.ts","../src/index.ts"],"sourcesContent":["interface PlaylistManifest {\n  files: string[];\n}\n\nexport class JsonAudioPlayer extends HTMLElement {\n  private $audio!: HTMLAudioElement;\n  private playlist: string[] = [];\n  private muxedBlobUrl: string | null = null;\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: \"open\" });\n    if (!this.shadowRoot) throw new Error(\"Shadow root not available\");\n    this.shadowRoot.innerHTML = `\n      <div>\n        <div id=\"status\">Loading...</div>\n        <audio id=\"audio\" controls></audio>\n      </div>\n    `;\n\n    this.$audio = this.shadowRoot.querySelector(\"#audio\")!;\n\n    this.$audio.addEventListener(\"ended\", () => {\n      console.log(\"Playback finished\");\n      this.dispatchEvent(new CustomEvent(\"playlistended\"));\n    });\n\n    this.$audio.addEventListener(\"error\", () => {\n      this.handleAudioError();\n    });\n  }\n\n  connectedCallback() {\n    console.log(`Audio player connected with src: ${this.getAttribute(\"src\")}`);\n    const src = this.getAttribute(\"src\")!;\n    this.loadAndMuxPlaylist(src);\n  }\n\n  disconnectedCallback() {\n    // Clean up blob URL when component is removed\n    if (this.muxedBlobUrl) {\n      URL.revokeObjectURL(this.muxedBlobUrl);\n    }\n  }\n\n  private updateStatus(message: string): void {\n    const statusEl = this.shadowRoot?.querySelector(\"#status\");\n    if (statusEl) {\n      statusEl.textContent = message;\n    }\n    console.log(message);\n  }\n\n  async loadAndMuxPlaylist(manifestUrl: string): Promise<void> {\n    try {\n      this.updateStatus(\"Loading playlist...\");\n\n      const response = await fetch(manifestUrl);\n      const manifest: PlaylistManifest = await response.json();\n      this.playlist = manifest.files;\n\n      console.log(`Found ${this.playlist.length} chunks to download and mux`);\n\n      // Download all chunks\n      this.updateStatus(`Downloading ${this.playlist.length} chunks...`);\n      const chunks: Blob[] = [];\n\n      for (let i = 0; i < this.playlist.length; i++) {\n        this.updateStatus(\n          `Downloading chunk ${i + 1}/${this.playlist.length}...`,\n        );\n        const chunkResponse = await fetch(this.playlist[i]);\n\n        if (!chunkResponse.ok) {\n          throw new Error(\n            `Failed to download chunk ${i + 1}: ${chunkResponse.statusText}`,\n          );\n        }\n\n        const blob = await chunkResponse.blob();\n        chunks.push(blob);\n        console.log(`Downloaded chunk ${i + 1}: ${blob.size} bytes`);\n      }\n\n      this.updateStatus(\"Muxing chunks into complete file...\");\n\n      // Combine all chunks into one blob\n      const combinedBlob = new Blob(chunks, { type: \"audio/webm\" });\n\n      // Create blob URL\n      this.muxedBlobUrl = URL.createObjectURL(combinedBlob);\n\n      this.updateStatus(\"Ready to play\");\n      this.$audio.src = this.muxedBlobUrl;\n\n      console.log(\"Successfully muxed all chunks into single playable file\");\n\n      // Dispatch ready event\n      this.dispatchEvent(new CustomEvent(\"ready\"));\n    } catch (error) {\n      console.error(\"Error loading and muxing playlist:\", error);\n      this.updateStatus(\n        `Error: ${error instanceof Error ? error.message : String(error)}`,\n      );\n      this.dispatchEvent(new CustomEvent(\"error\", { detail: error }));\n    }\n  }\n\n  private handleAudioError(): void {\n    const error = this.$audio.error;\n    if (!error) return;\n\n    const errorMessages: Record<number, string> = {\n      1: \"MEDIA_ERR_ABORTED - Loading was aborted\",\n      2: \"MEDIA_ERR_NETWORK - Network error while loading\",\n      3: \"MEDIA_ERR_DECODE - Error decoding audio\",\n      4: \"MEDIA_ERR_SRC_NOT_SUPPORTED - Audio format not supported or source not found\",\n    };\n\n    console.error(\n      `Audio playback error: ${error.code} - ${errorMessages[error.code] || \"Unknown error\"}`,\n    );\n    console.error(`Error message: ${error.message}`);\n\n    this.updateStatus(`Playback error: ${errorMessages[error.code]}`);\n\n    this.dispatchEvent(\n      new CustomEvent(\"playbackerror\", {\n        detail: {\n          errorCode: error.code,\n          errorMessage: error.message,\n        },\n      }),\n    );\n  }\n}\n\nexport function defineJsonAudioPlayer(tag = \"json-audio-player\") {\n  if (!customElements.get(tag)) {\n    customElements.define(tag, JsonAudioPlayer);\n  }\n}\n","import { defineJsonAudioPlayer } from \"./json-audio-player\";\n\ndefineJsonAudioPlayer();\n\n// Optional: export for advanced users (testing/custom tag names)\nexport * from \"./json-audio-player\";\n"],"names":["JsonAudioPlayer","src","message","statusEl","manifestUrl","manifest","chunks","i","chunkResponse","blob","combinedBlob","error","errorMessages","defineJsonAudioPlayer","tag"],"mappings":"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"}